#!/usr/bin/python
from pyalgotrade import strategy
from pyalgotrade import plotter
from pyalgotrade.tools import yahoofinance
from pyalgotrade.technical import bollinger
#from pyalgotrade.technical import linreg
from pyalgotrade.stratanalyzer import sharpe
import talib
from pyalgotrade.talibext import indicator
from pyalgotrade.technical import ma
#from pyalgotrade.technical import cross
from pyalgotrade.technical import rsi

import numpy

import xiquantFuncs
import xiquantStrategyParams as consts

#import Image
from matplotlib import pyplot

import json
#import jsonschema

import logging


###########Kiran's platform dependencies...
from pyalgotrade.barfeed import membf
import os
module_dir = os.path.dirname(__file__)  # get current directory



class BBands(strategy.BacktestingStrategy):
	def __init__(self, feed, instrument, bBandsPeriod, startPortfolio):
		strategy.BacktestingStrategy.__init__(self, feed, startPortfolio)
		self.__longPos = None
		self.__shortPos = None
		self.__entryDay = None
		self.__entryDayStopPrice = None
		self.__instrument = instrument
		self.setUseAdjustedValues(True)
		self.__priceDS = feed[instrument].getAdjCloseDataSeries()
		self.__openDS = feed[instrument].getOpenDataSeries()
		self.__closeDS = feed[instrument].getCloseDataSeries()
		self.__volumeDS = feed[instrument].getVolumeDataSeries()
		self.__bbands = bollinger.BollingerBands(feed[instrument].getCloseDataSeries(), bBandsPeriod, 2)
		self.__lowerBBDataSeries = self.__bbands.getLowerBand()
		self.__upperBBDataSeries = self.__bbands.getUpperBand()
		self.__bb_lower = 0
		self.__bb_middle = 0
		self.__bb_upper = 0
		self.__bb_period = bBandsPeriod
		# Count used to pick up the first day of the croc mouth opening
		self.__bbFirstCrocDay = 0
		self.__inpStrategy = None
		self.__inpEntry = None
		self.__inpExit = None
		self.__logger = None

	def initLogging(self):
		logger = logging.getLogger(__name__)
		logger.setLevel(logging.INFO)
		file_BB_Spread = os.path.join(module_dir, 'BB_Spread.log')
		handler = logging.FileHandler(file_BB_Spread)
		handler.setLevel(logging.DEBUG)
		formatter = logging.Formatter('%(asctime)s %(name)-12s %(levelname)-8s %(message)s')
		handler.setFormatter(formatter)
		logger.addHandler(handler)
		return logger
		
	def stopLogging(self):
		logging.shutdown()
		return
		
	def onStart(self):
		self.__logger = self.initLogging()
		self.__logger.info("Initial portfolio value: $%.2f" % self.getBroker().getEquity())
		self.__logger.debug("Load the input JSON strategy file.")
		file_json_strategies = os.path.join(module_dir, 'json_strategies')
		jsonStrategies = open(file_json_strategies)
		self.__inpStrategy = json.load(jsonStrategies)
		self.__logger.debug("Load the input JSON entry price file.")
		file_json_entry_price = os.path.join(module_dir, 'json_entry_price')
		jsonEntryPrice = open(file_json_entry_price)
		self.__inpEntry = json.load(jsonEntryPrice)
		self.__logger.debug("Load the input JSON exit price file.")
		file_json_exit_price = os.path.join(module_dir, 'json_exit_price')
		jsonExitPrice = open(file_json_exit_price)
		self.__inpExit = json.load(jsonExitPrice)

	def onFinish(self, bars):
		self.stopLogging()
		return

	def onEnterOk(self, position):
		execInfo = position.getEntryOrder().getExecutionInfo()
		self.__logger.info("%s: BOUGHT %d at $%.2f" % (execInfo.getDateTime(), execInfo.getQuantity(), execInfo.getPrice()))
		self.__logger.info("Portfolio cash after BUY: $%.2f" % self.getBroker().getCash())

		# Enter a stop loss order for the entry day
		if self.__longPos == position:
			self.__longPos.exitStop(self.__entryDayStopPrice, True)
			self.__logger.info("Stop Loss SELL order of %d %s shares set at %.2f" % (self.__longPos.getShares(), self.__instrument, self.__entryDayStopPrice))
		elif self.__shortPos == position: 
			self.__shortPos.exitStop(self.__entryDayStopPrice, True)
			self.__logger.info("Stop Loss BUY order of %d %s shares set at %.2f" % (self.__shortPos.getShares(), self.__instrument, self.__entryDayStopPrice))

	def onEnterCanceled(self, position):
		# This would have to be revisited as we would like to try and renter with
		# a higher price for options, as long as the entry point is within the
		# range that the tech. analysis has come up with.
		if self.__longPos == position:
			self.__longPos = None 
		elif self.__shortPos == position: 
			self.__shortPos = None 
		else: 
			assert(False)

	def onExitOk(self, position):
		execInfo = position.getExitOrder().getExecutionInfo()
		self.__logger.info("%s: SOLD %d at $%.2f" % (execInfo.getDateTime(), execInfo.getQuantity(), execInfo.getPrice()))
		self.__logger.info("Portfolio after SELL: $%.2f" % self.getBroker().getCash())
		if self.__longPos == position: 
			self.__longPos = None 
		elif self.__shortPos == position: 
			self.__shortPos = None 
		else: 
			assert(False)

	def onExitCanceled(self, position):
		# If the exit was canceled, re-submit it.
		######## This needs to be re-looked at as we constantly tighten the existing stop limit
		######## order by canceling the previous ones.
		# position.exitMarket()
		pass

	def getBollingerBands(self):
		return self.__bbands

	def onBars(self, bars):
		# Cancel any existing entry orders from yesterday.
		if self.__longPos:
			self.__longPos.cancelEntry()
		if self.__shortPos:
			self.__shortPos.cancelEntry()

		# Ensure that enough BB entries exist in the data series for running the
		# strategy.
		if len(self.__priceDS) < self.__bb_period + consts.BB_SLOPE_LOOKBACK_WINDOW:
			return

		lower = self.__bbands.getLowerBand()[-1]
		middle = self.__bbands.getMiddleBand()[-1]
		upper = self.__bbands.getUpperBand()[-1]
		if lower is None:
			return

		self.__bb_lower = lower
		self.__bb_middle = middle
		self.__bb_upper = upper
		bar = bars[self.__instrument]
		self.__logger.debug("%s: Lower: $%.2f" % (bar.getDateTime(), lower))
		self.__logger.debug("%s: Middle: $%.2f" % (bar.getDateTime(), middle))
		self.__logger.debug("%s: Upper: $%.2f" % (bar.getDateTime(), upper))
		self.__logger.debug("%s: Adj Close Price: $%.2f" % (bar.getDateTime(), bar.getAdjClose()))
		self.__logger.debug("%s: Open Price: $%.2f" % (bar.getDateTime(), bar.getOpen()))
		self.__logger.debug("%s: High Price: $%.2f" % (bar.getDateTime(), bar.getHigh()))
		self.__logger.debug("%s: Low Price: $%.2f" % (bar.getDateTime(), bar.getLow()))
		sharesToBuy = 0
	
		###### This needs to be fixed because we never explicitly exit from a position,
		###### we do so by setting the stop loss orders and let the market force us
		##### out of a position.
		if self.exitLongSignal(bar):
			if not self.__longPos.exitActive():
				self.__longPos.exitMarket()
				self.__logger.info("Exiting a LONG position")
				self.__logger.info("Portfolio: $%.2f" % self.getBroker().getCash())
		elif self.exitShortSignal(bar):
			if not self.__shortPos.exitActive():
				self.__shortPos.exitMarket()
				self.__logger.debug("Exiting a SHORT position")
				self.__logger.debug("Portfolio: $%.2f" % self.getBroker().getCash())
		else:
			if self.enterLongSignal(bar):
				# Bullish; enter a long position.
				self.__logger.info("Bullish; ENTERING a LONG position")
				currPrice = bar.getAdjClose()
				self.__logger.debug("%s: Close Price: $%.2f" % (bar.getDateTime(), currPrice))
				self.__logger.debug("%s: Open Price: $%.2f" % (bar.getDateTime(), bar.getOpen()))
				self.__logger.debug("%s: High Price: $%.2f" % (bar.getDateTime(), bar.getHigh()))
				self.__logger.debug("%s: Low Price: $%.2f" % (bar.getDateTime(), bar.getLow()))
				self.__logger.debug("%s: Portfolio: $%.2f" % (bar.getDateTime(), self.getBroker().getCash()))

				wickLen = bar.getHigh() - bar.getAdjClose()
				candleLen = bar.getAdjClose() - bar.getOpen()
				# Relative wick length as a percentage of the candle length
				relWickLen = (wickLen / candleLen) * 100
				# Set the limit price based on the relative wick length
				limitPrice = 0
				if "OR" in self.__inpEntry["BB_Spread_Call"] and "Long_Wick" in self.__inpEntry["BB_Spread_Call"]["OR"]:
					if abs(relWickLen) > consts.BB_LONG_WICK:
						if self.__inpEntry["BB_Spread_Call"]["OR"]["Long_Wick"] == "Half_Wick_Plus_Price_Delta":
							limitPrice = bar.getAdjClose() +  wickLen/2 + consts.PRICE_DELTA
					else:
						limitPrice = bar.getAdjClose() + wickLen + consts.PRICE_DELTA
				self.__logger.debug("%s: Wick Len: %.2f" % (bar.getDateTime(), wickLen))
				self.__logger.debug("%s: Candle Len: %.2f" % (bar.getDateTime(), candleLen))
				self.__logger.debug("%s: Wick Len as a percent of Candle Len: %.2f" % (bar.getDateTime(), abs(relWickLen)))
				self.__logger.debug("%s: Limit Price: %.2f" % (bar.getDateTime(), limitPrice))
				sharesToBuy = int((self.getBroker().getCash() * consts.PERCENT_OF_CASH_BALANCE_FOR_ENTRY) / limitPrice)
				self.__logger.debug("Shares To Buy: %d" % sharesToBuy)
				self.__longPos = self.enterLongLimit(self.__instrument, 
									limitPrice,
									sharesToBuy, True)
				if self.__longPos == None:
					self.__logger.debug("Couldn't go LONG %d shares" % sharesToBuy)
				else:
					if self.__longPos.entryActive() == True:
						self.__logger.debug("The LONG order for %d shares is active" % sharesToBuy)
					else:
						self.__logger.debug("LONG on %d shares" % abs(self.__longPos.getShares()))
					self.__entryDay = len(self.__priceDS) -1
					stopPrice = (bar.getOpen() + bar.getAdjClose()) / 2
					self.__entryDayStopPrice = stopPrice
			elif self.enterShortSignal(bar):
				# Bearish; enter a short position.
				self.__logger.info("Bearish; ENTERING a SHORT position")
				currPrice = bar.getAdjClose()
				self.__logger.debug("%s: Close Price: $%.2f" % (bar.getDateTime(), currPrice))
				self.__logger.debug("%s: Open Price: $%.2f" % (bar.getDateTime(), bar.getOpen()))
				self.__logger.debug("%s: High Price: $%.2f" % (bar.getDateTime(), bar.getHigh()))
				self.__logger.debug("%s: Low Price: $%.2f" % (bar.getDateTime(), bar.getLow()))
				self.__logger.debug("%s: Portfolio: $%.2f" % (bar.getDateTime(), self.getBroker().getCash()))

				wickLen = bar.getAdjClose() - bar.getLow()
				candleLen = bar.getOpen() - bar.getAdjClose()
				# Relative wick length as a percentage of the candle length
				relWickLen = (wickLen / candleLen) * 100
				# Set the limit price based on the relative wick length
				if "OR" in self.__inpEntry["BB_Spread_Put"] and "Long_Wick" in self.__inpEntry["BB_Spread_Put"]["OR"]:
					if abs(relWickLen) > consts.BB_LONG_WICK:
						if self.__inpEntry["BB_Spread_Put"]["OR"]["Long_Wick"] == "Half_Wick_Minus_Price_Delta":
							limitPrice = bar.getAdjClose() - wickLen/2 - consts.PRICE_DELTA
					else:
						limitPrice = bar.getAdjClose() - wickLen - consts.PRICE_DELTA
				self.__logger.debug("%s: Wick Len: %.2f" % (bar.getDateTime(), wickLen))
				self.__logger.debug("%s: Candle Len: %.2f" % (bar.getDateTime(), candleLen))
				self.__logger.debug( "%s: Wick Len as a percent of Candle Len: %.2f" % (bar.getDateTime(), abs(relWickLen)))
				self.__logger.debug( "%s: Limit Price: %.2f" % (bar.getDateTime(), limitPrice))
				sharesToBuy = int((self.getBroker().getCash() / 
								limitPrice) * consts.PERCENT_OF_CASH_BALANCE_FOR_ENTRY)
				self.__logger.debug( "Shares To Buy: %d" % sharesToBuy)
				self.__shortPos = self.enterShortLimit(self.__instrument, 
											limitPrice,
											sharesToBuy, True)
				if self.__shortPos == None:
					self.__logger.debug("Couldn't SHORT %d shares" % sharesToBuy)
				else:
					self.__logger.debug("SHORT on %d shares" % abs(self.__shortPos.getShares()))
					self.__entryDay = len(self.__priceDS) -1
					# Enter a stop limit order to exit here
					stopPrice = (bar.getOpen() + bar.getAdjClose()) / 2
					self.__entryDayStopPrice = stopPrice

	def enterLongSignal(self, bar):
		# Both the bands MUST open up like a crocodile mouth.
		if self.__inpStrategy["BB_Spread_Call"]["BB_Upper_And_BB_Lower"]["AND"][0] == "BB_Upper_Croc_Open" and self.__inpStrategy["BB_Spread_Call"]["BB_Upper_And_BB_Lower"]["AND"][1] == "BB_Lower_Croc_Open":
			if len(self.__bbands.getLowerBand()) > consts.BB_SLOPE_LOOKBACK_WINDOW:
				lowerSlope = xiquantFuncs.slope(self.__bbands.getLowerBand(), consts.BB_SLOPE_LOOKBACK_WINDOW)
				self.__logger.debug("Lower Slope: %d" % lowerSlope)
		
			if len(self.__bbands.getUpperBand()) >= consts.BB_SLOPE_LOOKBACK_WINDOW:
				upperSlope = xiquantFuncs.slope(self.__bbands.getUpperBand(), consts.BB_SLOPE_LOOKBACK_WINDOW)
				self.__logger.debug("Upper Slope: %d" % upperSlope)
		
			if  upperSlope < consts.BB_CROC_SLOPE or lowerSlope > -1 * consts.BB_CROC_SLOPE:
				return False

		# This should be the first day of the Bands opening as croc mouth.
		if self.__inpStrategy["BB_Spread_Call"]["BB_Upper_And_BB_Lower"]["AND"][2] == "BB_First_Croc_Open":
			if (self.__bbFirstCrocDay != 0) and (self.__bbFirstCrocDay != len(self.__priceDS) -1):
				self.__logger.debug("Not the first day of croc mouth opening")
				return False

		# Set this as the first day of the croc mouth opening
		self.__logger.debug("The first day of croc mouth opening")
		self.__bbFirstCrocDay = len(self.__priceDS) -1

		# Check if we already hold a position in this instrument
		if self.__longPos != None:
			return False

		# The close MUST breach or bounce off of the upper band.
		if self.__inpStrategy["BB_Spread_Call"]["BB_Upper_And_BB_Lower"]["OR"][0] == "BB_Upper_Breach":
			if bar.getAdjClose() > self.__bb_upper:
				self.__logger.debug("Upper band breached.")
			elif self.__inpStrategy["BB_Spread_Call"]["BB_Upper_And_BB_Lower"]["OR"][1] == "BB_Upper_Touch":
				# The close price may not exactly touch the upper band so we will have to
				# include some variance parameter
				if bar.getAdjClose() == self.__bb_upper:
					self.__logger.debug("Upper band touched.")
				else:
					return False

		# Check the price jump
		if self.__priceDS[-1] < self.__priceDS[-2]:
			return False
		bullishCandleJump = bar.getOpen() - self.__closeDS[-2]
		if bullishCandleJump <= 0:
			return False

		closePrice = bar.getAdjClose()
		if closePrice < consts.BB_PRICE_RANGE_HIGH_1:
			if float(bullishCandleJump / closePrice) * 100 >= consts.BB_SPREAD_PERCENT_INCREASE_RANGE_1:
				return False
		if closePrice < consts.BB_PRICE_RANGE_HIGH_2:
			if float(bullishCandleJump / closePrice) * 100 >= consts.BB_SPREAD_PERCENT_INCREASE_RANGE_2:
				return False
		if closePrice < consts.BB_PRICE_RANGE_HIGH_3:
			if float(bullishCandleJump / closePrice) * 100 >= consts.BB_SPREAD_PERCENT_INCREASE_RANGE_3:
				return False
		if closePrice >= consts.BB_PRICE_RANGE_HIGH_3:
			if float(bullishCandleJump / closePrice) * 100 >= consts.BB_SPREAD_PERCENT_INCREASE_RANGE_4:
				return False

		# Check Volume 
		if (len(self.__volumeDS) < consts.VOLUME_LOOKBACK_WINDOW): 
			return False 
		if self.__volumeDS[-1] <= self.__volumeDS[-1 * consts.VOLUME_LOOKBACK_WINDOW]: 
			return False 
		
		# Check cash flow 
		if len(self.__priceDS) < consts.CASH_FLOW_LOOKBACK_WINDOW: 
			return False
		### replace following with a loop 
		todayCashFlow = self.__priceDS[-1] * self.__volumeDS[-1] 
		yestCashFlow = self.__priceDS[-2] * self.__volumeDS[-2] 
		dayBeforeYestCashFlow = self.__priceDS[-3] * self.__volumeDS[-3] 
		twoDaysBeforeCashFlow = self.__priceDS[-4] * self.__volumeDS[-4] 
		if todayCashFlow <= float((yestCashFlow + dayBeforeYestCashFlow + twoDaysBeforeCashFlow) / 3): 
			return False

		# Add checks for other indicators here
		############
		return True

	def enterShortSignal(self, bar):
		# Both the bands MUST open up like a crocodile mouth.
		if self.__inpStrategy["BB_Spread_Put"]["BB_Upper_And_BB_Lower"]["AND"][0] == "BB_Upper_Croc_Open" and \
			self.__inpStrategy["BB_Spread_Put"]["BB_Upper_And_BB_Lower"]["AND"][1] == "BB_Lower_Croc_Open":
			if len(self.__bbands.getLowerBand()) > consts.BB_SLOPE_LOOKBACK_WINDOW:
				lowerSlope = xiquantFuncs.slope(self.__bbands.getLowerBand(), consts.BB_SLOPE_LOOKBACK_WINDOW)
				self.__logger.debug("Lower Slope: %d" % lowerSlope)
		
			if len(self.__bbands.getUpperBand()) >= consts.BB_SLOPE_LOOKBACK_WINDOW:
				upperSlope = xiquantFuncs.slope(self.__bbands.getUpperBand(), consts.BB_SLOPE_LOOKBACK_WINDOW)
				self.__logger.debug("Upper Slope: %d" % upperSlope)
		
			if  upperSlope < consts.BB_CROC_SLOPE or lowerSlope > -1 * consts.BB_CROC_SLOPE:
				return False

		# This should be the first day of the Bands opening as croc mouth.
		if self.__inpStrategy["BB_Spread_Put"]["BB_Upper_And_BB_Lower"]["AND"][2] == "BB_First_Croc_Open":
			if (self.__bbFirstCrocDay != 0) and (self.__bbFirstCrocDay != len(self.__priceDS) -1):
				self.__logger.debug("Not the first day of croc mouth opening")
				return False

		# Set this as the first day of the croc mouth opening
		self.__logger.debug("The first day of croc mouth opening")
		self.__bbFirstCrocDay = len(self.__priceDS) -1

		# Check if we already hold a position in this instrument
		if self.__shortPos != None:
			return False

		# The close MUST breach or bounce off of the lower band.
		if self.__inpStrategy["BB_Spread_Put"]["BB_Upper_And_BB_Lower"]["OR"][0] == "BB_Lower_Breach":
			if bar.getAdjClose() < self.__bb_lower:
				self.__logger.debug("Lower band breached.")
			elif self.__inpStrategy["BB_Spread_Put"]["BB_Upper_And_BB_Lower"]["OR"][1] == "BB_Lower_Touch":
				# The close price may not exactly touch the lower band so we will have to
				# include some variance parameter
				if bar.getAdjClose() == self.__bb_lower:
					self.__logger.debug("Lower band touched.")
				else:
					return False

		# Check the price jump
		if self.__priceDS[-1] > self.__priceDS[-2]:
			return False
		bearishCandleJump = self.__closeDS[-2] - bar.getOpen()
		if bearishCandleJump <= 0:
			return False

		closePrice = bar.getAdjClose()
		if closePrice < consts.BB_PRICE_RANGE_HIGH_1:
			if float(bearishCandleJump / closePrice) * 100 >= consts.BB_SPREAD_PERCENT_INCREASE_RANGE_1:
				return False
		if closePrice < consts.BB_PRICE_RANGE_HIGH_2:
			if float(bearishCandleJump / closePrice) * 100 >= consts.BB_SPREAD_PERCENT_INCREASE_RANGE_2:
				return False
		if closePrice < consts.BB_PRICE_RANGE_HIGH_3:
			if float(bearishCandleJump / closePrice) * 100 >= consts.BB_SPREAD_PERCENT_INCREASE_RANGE_3:
				return False
		if closePrice >= consts.BB_PRICE_RANGE_HIGH_3:
			if float(bearishCandleJump / closePrice) * 100 >= consts.BB_SPREAD_PERCENT_INCREASE_RANGE_4:
				return False

		# Check Volume 
		if (len(self.__volumeDS) < consts.VOLUME_LOOKBACK_WINDOW): 
			return False 
		if self.__volumeDS[-1] <= self.__volumeDS[-1 * consts.VOLUME_LOOKBACK_WINDOW]: 
			return False 
		
		# Check cash flow 
		if (len(self.__priceDS) < consts.CASH_FLOW_LOOKBACK_WINDOW): 
			return False 
		### replace following with a loop 
		todayCashFlow = self.__priceDS[-1] * self.__volumeDS[-1] 
		yestCashFlow = self.__priceDS[-2] * self.__volumeDS[-2] 
		dayBeforeYestCashFlow = self.__priceDS[-3] * self.__volumeDS[-3] 
		twoDaysBeforeCashFlow = self.__priceDS[-4] * self.__volumeDS[-4] 
		if (todayCashFlow <= (yestCashFlow + dayBeforeYestCashFlow + twoDaysBeforeCashFlow) / 3): 
			return False

		# Add checks for other indicators here
		############

		return True

	def exitLongSignal(self, bar):
		if len(self.__bbands.getLowerBand()) >= consts.BB_SLOPE_LOOKBACK_WINDOW:
			lowerSlope = xiquantFuncs.slope(self.__bbands.getLowerBand(), consts.BB_SLOPE_LOOKBACK_WINDOW)
			self.__logger.debug("Lower Slope: %d" % lowerSlope)
			if lowerSlope >= consts.BB_SLOPE_LIMIT_FOR_CURVING:
				# Reset the first croc mouth opening marker as the mouth is begin to close
				self.__logger.debug("Reset first croc opening day")
				self.__bbFirstCrocDay = 0

		# Check if we hold a position in this instrument or not
		if self.__longPos == None:
			return False

		# We don't explicitly exit but based on the indicators we just tighten the stop limit orders.
		if self.__entryDay == len(self.__priceDS) -1:
			# The stop limit order for the entry day has already been set.
			return False

		if lowerSlope >= consts.BB_SLOPE_LIMIT_FOR_CURVING:
			# Tighten the stop loss order
			stopPrice = ((100 - consts.BB_BAND_CURVES_IN_PRICE_TIGHTEN_PERCENT)/ 100) * bar.getAdjClose()
			# Cancel the exiting stop limit order before placing a new one
			self.__longPos.cancelExit()
			self.__longPos.exitStop(stopPrice, True)
			self.__logger.info("Tightened Stop Loss SELL order, due to lower band curving in, of %d %s shares set to %.2f" % (self.__longPos.getShares(), self.__instrument, stopPrice))
			return False
		# Tighten the stop loss order
		stopPrice = bar.getLow() - consts.BB_BAND_SECOND_DAY_BELOW
		# Cancel the exiting stop limit order before placing a new one
		self.__longPos.cancelExit()
		self.__longPos.exitStop(stopPrice, True)
		self.__logger.info("Tightened Stop Loss SELL order of %d %s shares set to %.2f" % (self.__longPos.getShares(), self.__instrument, stopPrice))
		return False
		
	def exitShortSignal(self, bar):
		if len(self.__bbands.getUpperBand()) >= consts.BB_SLOPE_LOOKBACK_WINDOW:
			upperSlope = xiquantFuncs.slope(self.__bbands.getUpperBand(), consts.BB_SLOPE_LOOKBACK_WINDOW)
			self.__logger.debug("Upper Slope: %d" % upperSlope)
			if upperSlope <= consts.BB_SLOPE_LIMIT_FOR_CURVING:
				# Reset the first croc mouth opening marker as the mouth is begin to close
				self.__logger.debug("Reset first croc opening day")
				self.__bbFirstCrocDay = 0

		# Check if we hold a position in this instrument or not
		if self.__shortPos == None:
			return False

		# We don't explicitly exit but based on the indicators we just tighten the stop limit orders.
		if self.__entryDay == len(self.__priceDS) -1:
			# The stop limit order for the entry day has already been set.
			return False

		if upperSlope <= consts.BB_SLOPE_LIMIT_FOR_CURVING:
			# Tighten the stop loss order
			stopPrice = ((100 + consts.BB_BAND_CURVES_IN_PRICE_TIGHTEN_PERCENT)/ 100) * bar.getOpen()
			# Cancel the exiting stop limit order before placing a new one
			self.__shortPos.cancelExit()
			self.__shortPos.exitStop(stopPrice, True)
			self.__logger.info("Tightened Stop Loss BUY order, due to upper band curving in, of %d %s shares set to %.2f" % (self.__shortPos.getShares(), self.__instrument, stopPrice))
			return False
		# Tighten the stop loss order
		stopPrice = bar.getHigh() + consts.BB_BAND_SECOND_DAY_BELOW
		# Cancel the exiting stop limit order before placing a new one
		self.__shortPos.cancelExit()
		self.__shortPos.exitStop(stopPrice, True)
		self.__logger.info("Tightened Stop Loss BUY order of %d %s shares set to %.2f" % (self.__shortPos.getShares(), self.__instrument, stopPrice))
		return False

def run_strategy(bBandsPeriod, instrument, startPortfolio, plot=False):

	# Download the bars
	feed = yahoofinance.build_feed([instrument], 2012, 2014, ".")

	strat = BBands(feed, instrument, bBandsPeriod, startPortfolio)

	if plot:
		plt = plotter.StrategyPlotter(strat, True, True, True)
		plt.getInstrumentSubplot(instrument).addDataSeries("upper", strat.getBollingerBands().getUpperBand())
		plt.getInstrumentSubplot(instrument).addDataSeries("middle", strat.getBollingerBands().getMiddleBand())
		plt.getInstrumentSubplot(instrument).addDataSeries("lower", strat.getBollingerBands().getLowerBand())

		strat.run()

		if plot:
			plt.plot()
			fileNameRoot = 'BB_spread_' + instrument
			(plt.buildFigure()).savefig(fileNameRoot + '.png', dpi=800)
			#Image.open(fileNameRoot + '.png').save(fileNameRoot + '.jpg', 'JPEG')

class Feed(membf.BarFeed):
    def __init__(self, frequency, maxLen=1024):
        membf.BarFeed.__init__(self, frequency, maxLen)

    def barsHaveAdjClose(self):
        return True

    def loadBars(self, instrument, bars):
        self.addBarsFromSequence(instrument, bars)

def redis_listoflists_to_dict(redis_list):
    list_values, list_keys = zip(*redis_list)
    return dict(zip(list_keys, list_values))

def redis_build_feed(ticker, stdate, enddate):

	import datetime
	import redis
	from time import mktime
	import urlparse
	import os
	from pyalgotrade.utils import dt
	from pyalgotrade.bar import BasicBar, Frequency


	seconds = mktime(stdate.timetuple())
	seconds2 = mktime(enddate.timetuple())

	redis_url = os.environ.get('REDISCLOUD_URL', 'redis://localhost:6379')
	url = urlparse.urlparse(redis_url)
	redisConn = redis.StrictRedis(host=url.hostname, port=url.port, password=url.password)
	redis_Adj_Open = redisConn.zrangebyscore(ticker+':Adj_Open', int(seconds*1000), int(seconds2*1000), 0, -1, True)
	redis_Adj_High = redisConn.zrangebyscore(ticker+':Adj_High', int(seconds*1000), int(seconds2*1000), 0, -1, True)
	redis_Adj_Low = redisConn.zrangebyscore(ticker+':Adj_Low', int(seconds*1000), int(seconds2*1000), 0, -1, True)
	redis_Adj_Close = redisConn.zrangebyscore(ticker+':Adj_Close', int(seconds*1000), int(seconds2*1000), 0, -1, True)
	redis_Adj_Volume = redisConn.zrangebyscore(ticker+':Adj_Volume', int(seconds*1000), int(seconds2*1000), 0, -1, True)

	#### Convert list of lists to dictionary to align keys...
	#### Please note we need to find better solution in the fuutre...
	#### Use adj_close as the master list of lists
	Adj_Open_dict = redis_listoflists_to_dict(redis_Adj_Open)
	Adj_High_dict = redis_listoflists_to_dict(redis_Adj_High)
	Adj_Low_dict = redis_listoflists_to_dict(redis_Adj_Low)
	Adj_Close_dict = redis_listoflists_to_dict(redis_Adj_Close)
	Adj_Volume_dict = redis_listoflists_to_dict(redis_Adj_Volume)
	

	bd = [] ##### initialize bar data.....
	for key in Adj_Close_dict:
	    Adj_Close = float(Adj_Close_dict[key])
	    dateTime = dt.timestamp_to_datetime(key/1000)

	    if (key in Adj_Open_dict) and (key in Adj_Low_dict) \
	        and (key in Adj_Volume_dict) and (key in Adj_High_dict):
	        Adj_Open = float(Adj_Open_dict[key])
	        Adj_High = float(Adj_High_dict[key])
	        Adj_Low = float(Adj_Low_dict[key])
	        Adj_Volume = float(Adj_Volume_dict[key])
	    else:
	        ##### Any of the missing keys set to adj_close....
	        Adj_Open = Adj_Close
	        Adj_High = Adj_Close
	        Adj_Low = Adj_Close
	        Adj_Volume = Adj_Close * 250000 ### Constant volume...
	        #print "$$$$$####@@@@", Adj_Close, Adj_Open, Adj_High, Adj_Low, Adj_Volume, dateTime

	    #print key, Adj_Close, Adj_Open, Adj_High, Adj_Low, Adj_Volume, dateTime  
	    bar = BasicBar(dateTime, 
	          Adj_Open , Adj_High, Adj_Low, Adj_Close, Adj_Volume, Adj_Close, Frequency.TRADE)
	    bd.append(bar)

	feed = Feed(Frequency.DAY, 1024)
	feed.loadBars(ticker, bd)
	return feed

def run_strategy_redis(bBandsPeriod, instrument, startPortfolio, startdate, enddate):
	from strategy_results import StrategyResults
	#import dateutil.parser
	from pyalgotrade.stratanalyzer import returns

	# Download the bars
	
	
	#startdate = dateutil.parser.parse('2012-01-01T08:00:00.000Z')
	#enddate = dateutil.parser.parse('2014-12-31T08:00:00.000Z')
	feed = redis_build_feed(instrument, startdate, enddate)
	#feed = yahoofinance.build_feed([instrument], 2012, 2014, ".")

	strat = BBands(feed, instrument, bBandsPeriod, startPortfolio)

	# Attach a returns analyzers to the strategy.
	returnsAnalyzer = returns.Returns()
	results = StrategyResults(strat, returnsAnalyzer)

	strat.run()
	#print results.getPortfolioResult()
	#print results.getCumulativeReturns()
	return results

	

	#if plot:
		#plt = plotter.StrategyPlotter(strat, True, True, True)
		#plt.getInstrumentSubplot(instrument).addDataSeries("upper", strat.getBollingerBands().getUpperBand())
		#plt.getInstrumentSubplot(instrument).addDataSeries("middle", strat.getBollingerBands().getMiddleBand())
		#plt.getInstrumentSubplot(instrument).addDataSeries("lower", strat.getBollingerBands().getLowerBand())
		


def main(plot):
	instruments = ["NFLX"]
	bBandsPeriod = 20
	startPortfolio = 1000000
	for inst in instruments:
		run_strategy(bBandsPeriod, inst, startPortfolio, plot)
		


if __name__ == "__main__":
	main(True)
